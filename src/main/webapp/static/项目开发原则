CRM项目开发目标
1. 编程思想
2. 代码含义(弄懂每一行代码)
3. 总结分析开发时的困难
4. 总结开发经验


每日笔记:
----------day1---------
  采用技术架构
    a. 视图层(View)
    	|-数据的展现
	 \-HTML技术(表现形式过于单一)
	  \-CSS技术(渲染页面,让页面更好看)
	|-用户的交互
	 \-JavaScript技术(原生代码太过繁杂)
	  \-jQuery(对js的封装,提高开发效率)
	|-bootstrap技术(对以上技术进行整体封装,提高效率)
	|-数据渲染
	 \-thymeleaf技术
    b. 控制层(Controller)
        |-整体的流程控制,调用业务层处理业务
	 \-servlet(处理请求及其发送来的数据)
	  \-springmvc(大大简化了开发,对数据自动封装)
    c. 业务层(Service)
    	|- JavaSE(处理业务逻辑,保证原子性)
    d. 持久化层(Repository)
	|-JDBC(操作数据库)
	 \-Mybatis(逆向工程)
    e. 整合层
   	|-spring(IOC,AOP管理依赖注入)

软件公司组织架构
  1.研发部(程序员[一般几十个,分成好几个项目,程序员之间分等级,包括项目经理和项目组长等]
  	   美工[一般一个项目两个,一个是主要进行前端页面开发,一个负责美术,画页面]
	   DBA[一般一个项目几个,主要对数据库开发,优化sql语句])
  2.测试部(找BUG)
  Ps:由于人情世故,当我们的代码出现BUG时,不要修复,留一点证明自己的价值,也给测开留点后路
  3.实施部(帮用户部署服务器,并装上软件) 
  4.产品部(设计产品)
  5.运维部(帮助客户维护产品)
  6.市场部***(拿项目)
软件开发的声明周期
 1:投标 -> 招标
 2.可行性分析(人力与资金) 
 3.需求分析
   3.1项目经理->项目原型:更便于客户确定他所需要的需求[不要写的太华丽,避免客户加需求]
   3.2需求调研->主要是对客户进行需求调研{如果遇到难做的项目,可介绍替代方案,不要说难做} 
   3.3>>>需求文档<<<
 4.分析与设计
 |+架构设计(整体)
  \+物理架构分析(主要是硬件层面的分析)
   \-应用服务器:tomcat{tomcat支持的协议有限,大公司一般不用}  --- JavaEE 企业应用开发
   \-数据库服务器:MySQL,Oracle....
  \+逻辑架构分析(代码分层 视图->控制->业务->持久化)
  \+技术选型
    Java(除了Java,其他技术也可以开发web应用) 
 ----------------day2---------------
 |+项目设计(具体)
 \-物理模型设计:项目经理来决定数据库中表,表中字段,字段类型与长度,表的关系等
 	PowerDesigner .pdm
 \-逻辑模型设计:程序员来设计类,类里面的方法和属性以及对应所需要的功能,类的关系等
 	RationalROse .pdl
 \-界面设计:产品经理与美工共同设计界面,类似于项目模型
  \+企业级应用: 朴素,效率要求不高
  \-互联网应用: 炫酷,需要高效
 \-算法设计:项目经理设计算法来调高项目的效率
5.搭建开发环境
  创建maven工程,配置依赖,配置配置文件...
  一般分布式版本控制来完成
6.编码实现 --- 注释
7.测试  --- 测试用例
  一般编码实现与测试交替进行
8.试运行 --- 使用手册
9.上线(给钱) --- 实施手册
10.运维[一个产品的生命周期一般都是几年] --- 运维手册
 	每一个阶段都要杜撰文档
	标书,可行性分析报告,需求文档,架构文档,项目设计文档,算法设计文档,技术架构文档,项目模型 ---
!!CRM项目介绍
    1)CRM Customer Relationship Management 客户关系管理系统
    2)CRM项目属于传统项目,企业级项目,一般技术要求不高,并发访问较低
    3)CRM的宗旨:留住老客户,争取新客户,把已有客户变为忠诚客户
    4)CRM本质是一类项目,本CRM主要面对进出口贸易公司,贸易大宗受管制的商品
!!CRM核心业务
    1)系统管理功能
        主要是涉及用户登录,登陆验证,安全退出等与业务无关的功能又保障了业务功能的正常运行
    2)业务管理功能
        处理业务数据
            a.市场活动
            b.线索
            c.客户
            d.联系人
            e.交易
            f.售后回访  ×(不做)
            g.统计图表
!!!物理模型设计
    项目经理:通过项目原型和需求文档分析得出
    涉及到的表
        tbl_user 用户表

        tbl_dic_type 数据字典类型表
        tbl_dic_val  数据字典值表

        tbl_activity         市场活动表
        tbl_activity_remark  市场活动备注表

        tbl_clue_activity_relation 线索和市场活动关联表

        tbl_clue            线索表
        tbl_clue_remark     线索备注表

        tbl_customer          客户表
        tbl_customer_remark   客户备注表

        tbl_contacts            联系人表
        tbl_contacts_remark     联系人备注表

        tbl_contacts_activity_relation 联系人和市场活动关联表

        tbl_tran               交易表
        tbl_tran_remark        交易备注表
        tbl_tran_history       交易历史表
----------------day3---------------
1)主键字段:唯一确定表中的一条记录
    一般不会使用联合主键,原因是联合主键可能会出现索引失效问题
    一般不会使用业务字段为主键,原因是业务字段具有不确定性,会造成聚簇索引不断重构,添加效率极低
    主键的数据类型以及长度由主键值来决定
        自增:不推荐使用,原因是在高并发的环境下,由于自增锁的锁机制,在批量插入数据的时候会形成一个自增表锁,对其他线程造成阻塞
        assigned:常用UUID算法,不仅能保证非空且唯一,且是整体自增的,不会破坏聚簇索引,大小为定长32位,是int的完美替代品,不会阻塞
        共享主键:不推荐使用,表之间的耦合度太高,可以结合成一个表提高效率,不合理
2)外键字段:表与表之间的关系
    一对多关系:一条记录对应多条记录
            一般在多的一方加外键
        先添加父表的数据,再添加子表的数据
        先删除子表的数据,再删除父表的数据 ---> 外键约束的要求
        \+采取内连接还是外连接看外键是否可以为空,外键可以为空,一般采取外连接,如果不可以为空,一般采取内连接
        \-归根结底看需求
    一对一关系:一条记录对应一条记录
        共享主键的方式
            先添加先产生的表,后添加后产生的表
            先删除后产生的表,后删除先产生的表 ---> 共享主键(不推荐,耦合度太高) -- 如果删了先产生的表,后产生的数据就删不了了
            !几乎不会用,理论如此!
        唯一外键的方式
            在后加表添加唯一外键(如果不唯一,那么就不可以满足一对一关系了)
            一对一关系是特殊的一对多关系,操作与一对多类似
    多对多关系:两张表中都是一条记录对应多条记录
        对于多对多关系,无论在那张表中加外键都不可以表示多对多关系,此时我们需要引入一个中间表(关联表)
        关联表
            关联表中主要存储两张表的主键,从而表示多对多的关系
            关联表里面的主键释义为外键,主要担任多的角色
            关联表中的外键不可以为空,所以使用内连接即可
            对于关联表的外键,其对应的主键必须存在
        先添加两张表的数据,后添加关联表的数据
        先删除关联表的数据,后删除两张表的数据 注意:一条记录中,删某个表主键,把对应的表的记录删掉再删另一个

    Date日期类遇到字符串会隐式转换,无需担心

`开发` --> 先开发`被依赖的功能`
一:前期准备
    1.创建数据库实例,执行sql脚本
    2.创建工程,配置以来
    3.整合SSM
    4.导入项目模板(模板的分类,为了更好的管理)
    5.配置web服务器
二:页面
    1.需求分析
    2.分析与设计
    3.编码
    4.测试

    2.1首页功能
    要点:
        1.一个资源目录对应着一个Controller,这样做的目的是为了方便管理,viewController的作用体现不出来了,资源目录的选取以转发视图所在目录为参考
        2.在写代码的时候我们需要先写底层的代码层
        3.将业务管理功能和系统管理功能分开写
        4.多个资源目录的原因也是为了方便管理
        5.映射路径需要和资源目录所在路径一致,资源名称和方法名保持一致,这样才能方便管理{由于大家都在views下,所以前面那层可以不写}
        6.上下文路径应该是动态的,否则除了本机都无法正常访问
    额外小知识:
        1.映射路径不可以写上下文路径
        2.部署到web服务器下的html资源可以从当前部署路径找其他资源(很麻烦,不用)
        3.ctrl+R 批量替换

    2.2登录功能
    要点:
        1.优先使用同步请求,按照需求来使用异步请求
            全局刷新用同步,部分刷新用异步,两者都有用异步
        2.service层,和mapper都以表为单位创建
        3.mybatis逆向工程的插件和配置文件都是一次性的,所以不需要部署到服务器上,要另作一个工程去创建,也是为了安全性
        4.在返回json格式字符串时,返回值类型写Object,这样灵活性更高,代码更通用,返回的对象转换成json格式字符串是根绝实际返回的对象来决定的
        5.在映射路径最后的地方加.do
        6.慎用Map,Map效率低,封装JSON的对象不能是Map集合
        7.跨模块使用的,放在commons包下
        8.非必要时,属性都定义成字符换,不论是数据库还是前端都易于解析,最后通常定义为Object,拓展性更强,可以放其他数据包括另外同等作用的实体类
        9.不要在html里面写js代码,代码混合起来了不好维护
        10.不要引入过多的js文件,否则降低效率
        11.数据验证,如果不验证数据直接往后台发请求,遇到不合法数据也处理,会大大加大后台负担
        12.对于重复使用的代码片段,封装成工具类的静态方法,对于重复使用的变量,封装成常量[constants包]
            页面封装不了常量
        13.控制层中的数据给视图层,一般采用域对象
        14. 同一个请求间的共享数据(request) 不同请求间的共享数据(session) 所有用户共享数据(application)
        15. 往域对象放东西的时候,key也不要写死
        16.在登录的时候,需要告诉用户验证中,挽留用户

    新知识:
        1.getRemoteAddr();获取用户的ip地址 getServerName()获取主机ip地址
        2.getRealPath() 或着是 getContextPath | @{}都是获取主机相关路径的
        3.attr获取指定元素的指定属性值,但是获取不到true或者false这些值,可以选择prop,用法与attr一致,但是可以获取true或false[checked,selected,readonly,disabled]
        4.ajax新参数:beforeSend,绑定一个回调函数,表示发请求前执行回调函数,返回true,发送ajax请求,否则不发送
        5.cookie的name一样,cookie会发生覆盖,包括生命周期

    开发反省:
        1. 如果找不到资源,可以从部署环境,war包,组件扫描方向去解决

    2,3安全退出
    要点:
        1.重定向视图和转发视图不需要配置视图解析器,默认携带视图解析器,如果以/开头,会自动加上上下文路径
    新知识:
        1.invalidate()销毁session

    2.4登录验证
    要点:
        1.资源目录的标准为路径,在拦截器充分体现其优势
        2.如果过滤的需求比较复杂,使用拦截器,如果过滤需求比较简单,用过滤器过滤器功能单一且书写麻烦
        3.拦截器对过滤器进行了封装
        4.拦截器重定向用原生API
        5.拦截器配置的路径中也不需要写上下文路径

    新知识:
        1.排除拦截的优先级更高
    2.5页面切割技术
        {<frameset>:主要用于页面切割,里面有两大属性,不过只能写其中一个,互相排斥
        rows='40%,20%,40%':意思是按照行来切割,自上而下占比情况
        cols='10%,90%':意思是按照列来切割,自左到右占比情况
        <frame>:主要用于页面的显示
        src='url' name='' 唯一表示一个窗口,用于指定返回的窗口
        例子<a> src='url' target='name'</a>在指定窗口打开超链接
        } 已过时
        原因是:frame所引入的是一个完整的网页,只是小了一点,每一个网页都有bom和dom,体积巨大,网络传输量大
        如果里面的某一个页面被刷新,就叫全局刷新
        <div>主要用于页面切割,可以通过样式随意进行切割,相较之前具有更大的灵活性
        <iframe>主要用于显示页面,属性:href与上述src一致,都有name
        最大的优点是轻量级
    2.6 模态窗口
        常规方式:可以通过window.open(url,窗口名称)来打开一个新窗口,但是,这两个窗口的页面独立存在,要想实现两个窗口资源上的通信
        我们需要给两个document对象增加parent与children的关系,但是,对于编码而言很复杂,jquery调用困难

        模态窗口:本质上不是一个窗口,是一个普通的<div>,通过设置z-index,开始时z-index<0,被页面遮住,后来z-index>0,又显示了出来
        从而给我们窗口的幻觉
        模态窗口通过bootstrap实现,通过class = 'modal fade' 标识为一个模态窗口

        控制模态窗口的显示与隐藏
        方式一:属性modal-toggle='modal' modal-target='#id' 点击就可以显示模态窗口,再点一下隐藏模态窗口
        方式二:选择器.modal('show') 显示模态窗口  选择器.modal('hide') 隐藏模态窗口
        方式三:属性modal-dismiss='modal' 隐藏该标签所在的模态窗口

    3.1市场活动页面
    要点:
        1.查询用户的时候不仅要查询name,还要查询UUID,底层保存的是UUID,且过滤条件
        2.UUID.randomUUID.toString() 生成的字符串含'-',我们需要将其替代为''
        3.createBy,放id进去,因为name可能会重名,也因为市场活动表和用户表存在着一对多关系
        4.一般写数据会因为用户操作的因素导致异常,所以我们需要异常处理,而且出现异常或写入不成功时,提示信息隐晦一点
        5.用户自己输入的都去空格
        6.js字符串可以直接比较大小
        7.正则表达式语法通则
            1)//
            2)^
            3)$
            4)[]
            5){}
            6)\d 所有的数字 \D 非数字 \w 字符 \W 非字符
            7)* + ?
        8.调用API原则:  1)实现起来了比较复杂 2)与具体的业务无关
          前端插件开发步骤:
            a.引入开发包:下载对应的开发包,在html中引入 [1.日期类开发包依赖bootstrap,bootstrap依赖jquery,所以要先引入被依赖的,一共三个]
            b.创建容器:容器用于存储插件得到的结果,<div> <input>等
                选择器(容器).datetimepicker({
                    minView:'month', // 表示可以选到月份
                    autoclose:true, // 表示选择完最小视图后,自动关闭
                    language:'zh-CN', // 表示地区是中国,中国日历
                    initialDate:new Date(), // 初始的时间,表示当前时间是初始时间
                    format:'yyyy-mm-dd' // 格式化时间
                })
            c.加载完容器后,在容器调用插件
     新知识点:
        1.reset()方法可以重置form表单,是DOM对象的方法


任务:创建市场活动时序图,创建市场活动





