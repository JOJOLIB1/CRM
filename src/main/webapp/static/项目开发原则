CRM项目开发目标
1. 编程思想
2. 代码含义(弄懂每一行代码)
3. 总结分析开发时的困难
4. 总结开发经验


每日笔记:
----------day1---------
  采用技术架构
    a. 视图层(View)
    	|-数据的展现
	 \-HTML技术(表现形式过于单一)
	  \-CSS技术(渲染页面,让页面更好看)
	|-用户的交互
	 \-JavaScript技术(原生代码太过繁杂)
	  \-jQuery(对js的封装,提高开发效率)
	|-bootstrap技术(对以上技术进行整体封装,提高效率)
	|-数据渲染
	 \-thymeleaf技术
    b. 控制层(Controller)
        |-整体的流程控制,调用业务层处理业务
	 \-servlet(处理请求及其发送来的数据)
	  \-springmvc(大大简化了开发,对数据自动封装)
    c. 业务层(Service)
    	|- JavaSE(处理业务逻辑,保证原子性)
    d. 持久化层(Repository)
	|-JDBC(操作数据库)
	 \-Mybatis(逆向工程)
    e. 整合层
   	|-spring(IOC,AOP管理依赖注入)

软件公司组织架构
  1.研发部(程序员[一般几十个,分成好几个项目,程序员之间分等级,包括项目经理和项目组长等]
  	   美工[一般一个项目两个,一个是主要进行前端页面开发,一个负责美术,画页面]
	   DBA[一般一个项目几个,主要对数据库开发,优化sql语句])
  2.测试部(找BUG)
  Ps:由于人情世故,当我们的代码出现BUG时,不要修复,留一点证明自己的价值,也给测开留点后路
  3.实施部(帮用户部署服务器,并装上软件) 
  4.产品部(设计产品)
  5.运维部(帮助客户维护产品)
  6.市场部***(拿项目)
软件开发的声明周期
 1:投标 -> 招标
 2.可行性分析(人力与资金) 
 3.需求分析
   3.1项目经理->项目原型:更便于客户确定他所需要的需求[不要写的太华丽,避免客户加需求]
   3.2需求调研->主要是对客户进行需求调研{如果遇到难做的项目,可介绍替代方案,不要说难做} 
   3.3>>>需求文档<<<
 4.分析与设计
 |+架构设计(整体)
  \+物理架构分析(主要是硬件层面的分析)
   \-应用服务器:tomcat{tomcat支持的协议有限,大公司一般不用}  --- JavaEE 企业应用开发
   \-数据库服务器:MySQL,Oracle....
  \+逻辑架构分析(代码分层 视图->控制->业务->持久化)
  \+技术选型
    Java(除了Java,其他技术也可以开发web应用) 
 ----------------day2---------------
 |+项目设计(具体)
 \-物理模型设计:项目经理来决定数据库中表,表中字段,字段类型与长度,表的关系等
 	PowerDesigner .pdm
 \-逻辑模型设计:程序员来设计类,类里面的方法和属性以及对应所需要的功能,类的关系等
 	RationalROse .pdl
 \-界面设计:产品经理与美工共同设计界面,类似于项目模型
  \+企业级应用: 朴素,效率要求不高
  \-互联网应用: 炫酷,需要高效
 \-算法设计:项目经理设计算法来调高项目的效率
5.搭建开发环境
  创建maven工程,配置依赖,配置配置文件...
  一般分布式版本控制来完成
6.编码实现 --- 注释
7.测试  --- 测试用例
  一般编码实现与测试交替进行
8.试运行 --- 使用手册
9.上线(给钱) --- 实施手册
10.运维[一个产品的生命周期一般都是几年] --- 运维手册
 	每一个阶段都要杜撰文档
	标书,可行性分析报告,需求文档,架构文档,项目设计文档,算法设计文档,技术架构文档,项目模型 ---
!!CRM项目介绍
    1)CRM Customer Relationship Management 客户关系管理系统
    2)CRM项目属于传统项目,企业级项目,一般技术要求不高,并发访问较低
    3)CRM的宗旨:留住老客户,争取新客户,把已有客户变为忠诚客户
    4)CRM本质是一类项目,本CRM主要面对进出口贸易公司,贸易大宗受管制的商品
!!CRM核心业务
    1)系统管理功能
        主要是涉及用户登录,登陆验证,安全退出等与业务无关的功能又保障了业务功能的正常运行
    2)业务管理功能
        处理业务数据
            a.市场活动
            b.线索
            c.客户
            d.联系人
            e.交易
            f.售后回访  ×(不做)
            g.统计图表
!!!物理模型设计
    项目经理:通过项目原型和需求文档分析得出
    涉及到的表
        tbl_user 用户表

        tbl_dic_type 数据字典类型表
        tbl_dic_val  数据字典值表

        tbl_activity         市场活动表
        tbl_activity_remark  市场活动备注表

        tbl_clue_activity_relation 线索和市场活动关联表

        tbl_clue            线索表
        tbl_clue_remark     线索备注表

        tbl_customer          客户表
        tbl_customer_remark   客户备注表

        tbl_contacts            联系人表
        tbl_contacts_remark     联系人备注表

        tbl_contacts_activity_relation 联系人和市场活动关联表

        tbl_tran               交易表
        tbl_tran_remark        交易备注表
        tbl_tran_history       交易历史表
----------------day3---------------
1)主键字段:唯一确定表中的一条记录
    一般不会使用联合主键,原因是联合主键可能会出现索引失效问题
    一般不会使用业务字段为主键,原因是业务字段具有不确定性,会造成聚簇索引不断重构,添加效率极低
    主键的数据类型以及长度由主键值来决定
        自增:不推荐使用,原因是在高并发的环境下,由于自增锁的锁机制,在批量插入数据的时候会形成一个自增表锁,对其他线程造成阻塞
        assigned:常用UUID算法,不仅能保证非空且唯一,且是整体自增的,不会破坏聚簇索引,大小为定长32位,是int的完美替代品,不会阻塞
        共享主键:不推荐使用,表之间的耦合度太高,可以结合成一个表提高效率,不合理
2)外键字段:表与表之间的关系
    一对多关系:一条记录对应多条记录
            一般在多的一方加外键
        先添加父表的数据,再添加子表的数据
        先删除子表的数据,再删除父表的数据 ---> 外键约束的要求
        \+采取内连接还是外连接看外键是否可以为空,外键可以为空,一般采取外连接,如果不可以为空,一般采取内连接
        \-归根结底看需求
    一对一关系:一条记录对应一条记录
        共享主键的方式
            先添加先产生的表,后添加后产生的表
            先删除后产生的表,后删除先产生的表 ---> 共享主键(不推荐,耦合度太高) -- 如果删了先产生的表,后产生的数据就删不了了
            !几乎不会用,理论如此!
        唯一外键的方式
            在后加表添加唯一外键(如果不唯一,那么就不可以满足一对一关系了)
            一对一关系是特殊的一对多关系,操作与一对多类似
    多对多关系:两张表中都是一条记录对应多条记录
        对于多对多关系,无论在那张表中加外键都不可以表示多对多关系,此时我们需要引入一个中间表(关联表)
        关联表
            关联表中主要存储两张表的主键,从而表示多对多的关系
            关联表里面的主键释义为外键,主要担任多的角色
            关联表中的外键不可以为空,所以使用内连接即可
            对于关联表的外键,其对应的主键必须存在
        先添加两张表的数据,后添加关联表的数据
        先删除关联表的数据,后删除两张表的数据 注意:一条记录中,删某个表主键,把对应的表的记录删掉再删另一个

    Date日期类遇到字符串会隐式转换,无需担心

`开发` --> 先开发`被依赖的功能`
一:前期准备
    1.创建数据库实例,执行sql脚本
    2.创建工程,配置以来
    3.整合SSM
    4.导入项目模板(模板的分类,为了更好的管理)
    5.配置web服务器
二:页面
    1.需求分析
    2.分析与设计
    3.编码
    4.测试

    2.1首页功能
    要点:
        1.一个资源目录对应着一个Controller,这样做的目的是为了方便管理,viewController的作用体现不出来了,资源目录的选取以转发视图所在目录为参考
        2.在写代码的时候我们需要先写底层的代码层
        3.将业务管理功能和系统管理功能分开写
        4.多个资源目录的原因也是为了方便管理
        5.映射路径需要和资源目录所在路径一致,资源名称和方法名保持一致,这样才能方便管理{由于大家都在views下,所以前面那层可以不写}
        6.上下文路径应该是动态的,否则除了本机都无法正常访问
    额外小知识:
        1.映射路径不可以写上下文路径
        2.部署到web服务器下的html资源可以从当前部署路径找其他资源(很麻烦,不用)
        3.ctrl+R 批量替换

    2.2登录功能
    要点:
        1.优先使用同步请求,按照需求来使用异步请求
            全局刷新用同步,部分刷新用异步,两者都有用异步
        2.service层,和mapper都以表为单位创建
        3.mybatis逆向工程的插件和配置文件都是一次性的,所以不需要部署到服务器上,要另作一个工程去创建,也是为了安全性
        4.在返回json格式字符串时,返回值类型写Object,这样灵活性更高,代码更通用,返回的对象转换成json格式字符串是根绝实际返回的对象来决定的
        5.在映射路径最后的地方加.do
        6.慎用Map,Map效率低,封装JSON的对象不能是Map集合
        7.跨模块使用的,放在commons包下
        8.非必要时,属性都定义成字符换,不论是数据库还是前端都易于解析,最后通常定义为Object,拓展性更强,可以放其他数据包括另外同等作用的实体类
        9.不要在html里面写js代码,代码混合起来了不好维护
        10.不要引入过多的js文件,否则降低效率
        11.数据验证,如果不验证数据直接往后台发请求,遇到不合法数据也处理,会大大加大后台负担
        12.对于重复使用的代码片段,封装成工具类的静态方法,对于重复使用的变量,封装成常量[constants包]
            页面封装不了常量
        13.控制层中的数据给视图层,一般采用域对象
        14. 同一个请求间的共享数据(request) 不同请求间的共享数据(session) 所有用户共享数据(application)
        15. 往域对象放东西的时候,key也不要写死
        16.在登录的时候,需要告诉用户验证中,挽留用户

    新知识:
        1.getRemoteAddr();获取用户的ip地址 getServerName()获取主机ip地址
        2.getRealPath() 或着是 getContextPath | @{}都是获取主机相关路径的
        3.attr获取指定元素的指定属性值,但是获取不到true或者false这些值,可以选择prop,用法与attr一致,但是可以获取true或false[checked,selected,readonly,disabled]
        4.ajax新参数:beforeSend,绑定一个回调函数,表示发请求前执行回调函数,返回true,发送ajax请求,否则不发送
        5.cookie的name一样,cookie会发生覆盖,包括生命周期

    开发反省:
        1. 如果找不到资源,可以从部署环境,war包,组件扫描方向去解决

    2,3安全退出
    要点:
        1.重定向视图和转发视图不需要配置视图解析器,默认携带视图解析器,如果以/开头,会自动加上上下文路径
    新知识:
        1.invalidate()销毁session

    2.4登录验证
    要点:
        1.资源目录的标准为路径,在拦截器充分体现其优势
        2.如果过滤的需求比较复杂,使用拦截器,如果过滤需求比较简单,用过滤器过滤器功能单一且书写麻烦
        3.拦截器对过滤器进行了封装
        4.拦截器重定向用原生API
        5.拦截器配置的路径中也不需要写上下文路径

    新知识:
        1.排除拦截的优先级更高
    2.5页面切割技术
        {<frameset>:主要用于页面切割,里面有两大属性,不过只能写其中一个,互相排斥
        rows='40%,20%,40%':意思是按照行来切割,自上而下占比情况
        cols='10%,90%':意思是按照列来切割,自左到右占比情况
        <frame>:主要用于页面的显示
        src='url' name='' 唯一表示一个窗口,用于指定返回的窗口
        例子<a> src='url' target='name'</a>在指定窗口打开超链接
        } 已过时
        原因是:frame所引入的是一个完整的网页,只是小了一点,每一个网页都有bom和dom,体积巨大,网络传输量大
        如果里面的某一个页面被刷新,就叫全局刷新
        <div>主要用于页面切割,可以通过样式随意进行切割,相较之前具有更大的灵活性
        <iframe>主要用于显示页面,属性:href与上述src一致,都有name
        最大的优点是轻量级
    2.6 模态窗口
        常规方式:可以通过window.open(url,窗口名称)来打开一个新窗口,但是,这两个窗口的页面独立存在,要想实现两个窗口资源上的通信
        我们需要给两个document对象增加parent与children的关系,但是,对于编码而言很复杂,jquery调用困难

        模态窗口:本质上不是一个窗口,是一个普通的<div>,通过设置z-index,开始时z-index<0,被页面遮住,后来z-index>0,又显示了出来
        从而给我们窗口的幻觉
        模态窗口通过bootstrap实现,通过class = 'modal fade' 标识为一个模态窗口

        控制模态窗口的显示与隐藏
        方式一:属性modal-toggle='modal' modal-target='#id' 点击就可以显示模态窗口,再点一下隐藏模态窗口
        方式二:选择器.modal('show') 显示模态窗口  选择器.modal('hide') 隐藏模态窗口
        方式三:属性modal-dismiss='modal' 隐藏该标签所在的模态窗口

    3.1市场活动页面
    要点:
        1.查询用户的时候不仅要查询name,还要查询UUID,底层保存的是UUID,且过滤条件
        2.UUID.randomUUID.toString() 生成的字符串含'-',我们需要将其替代为''
        3.createBy,放id进去,因为name可能会重名,也因为市场活动表和用户表存在着一对多关系
        4.一般写数据会因为用户操作的因素导致异常,所以我们需要异常处理,而且出现异常或写入不成功时,提示信息隐晦一点
        5.用户自己输入的都去空格
        6.js字符串可以直接比较大小
        7.正则表达式语法通则
            1)//
            2)^
            3)$
            4)[]
            5){}
            6)\d 所有的数字 \D 非数字 \w 字符 \W 非字符
            7)* + ?
        8.调用API原则:  1)实现起来了比较复杂 2)与具体的业务无关
          前端插件开发步骤:
            a.引入开发包:下载对应的开发包,在html中引入 [1.日期类开发包依赖bootstrap,bootstrap依赖jquery,所以要先引入被依赖的,一共三个]
            b.创建容器:容器用于存储插件得到的结果,<div> <input>等
                选择器(容器).datetimepicker({
                    minView:'month', // 表示可以选到月份
                    autoclose:true, // 表示选择完最小视图后,自动关闭
                    language:'zh-CN', // 表示地区是中国,中国日历
                    initialDate:new Date(), // 初始的时间,表示当前时间是初始时间
                    format:'yyyy-mm-dd' // 格式化时间
                    todayBtn:true, // 今天按钮,返回今天
                    clearBtn:true // 清空按钮,注意要改中文
                })
            c.加载完容器后,在容器调用插件

        9.没有对应的实体类对象就封装成一个map
        10.如果对数据表进行写操作,不可以将写操作放在不同的方法中,会导致数据不一致,因为不是同一个事务
        11.视图层上面的通常显示的是名字,而底层数据存放的是对应的UUID,所以,我们需要多表查询
        12.映射文件中,小于号可能会与标签冲突,要使用转义
        13.注意:pageInfo放在域对象里面不合适,因为这是ajax请求,响应json,并没有页面跳转与解析,thymeleaf不起作用
        14.在入口函数外封装函数
        15.js善于运用全局变量
        16.如果改变了每一页显示条数,我们必须返回第一页,因为当前页可能会因此而消失
        17.需要用隐藏域接收id,id用于修改数据
        18.
            如果作为查询条件,且没有对应的实体类对象,一般封装成map集合
            如果写数据,有对应的实体类对象,一般封装成对应的实体类对象

        19.
    新知识点:
        1.reset()方法可以重置form表单,是DOM对象的方法
        2.disabled不可以提交,readonly可以提交
        3.一个标签可以有多个类,用空格隔开
        4.order by 和 limit 顺序不同,效果不同
        5.选择器>标签名 相当于获取该选择器下面的直接子标签
          选择器 标签名 相当于获取该选择器下所有的子标签
        6.jquery的函数都是批量操作的
        7.选择器.事件(func) 该方式只能给固有元素加事件
            固有元素:调用该事件函数之前,对应的标签已经存在
            动态元素:调用该事件函数之前,对应的标签还未存在
            这里是动态元素的原因:
                我们首先调用的是发送请求的函数,由于ajax支持异步请求,所以会给其分配一个独立的线程执行,当前线程继续往下
                执行,会导致没有生成标签的时候,就执行到事件函数了,所以是生成的是动态元素
            语法
                父选择器.on(事件名, 子选择器, func) 该方式可以给动态元素加事件也可以给固有元素加事件
                父元素:必须是固有元素,直接或间接都可以,越小越好,因为这样收到其他标签的干扰少
        8.在多表查询中,mapUnderscoreToCamelcase失效
        9.在修改的时候,把对应的value值赋值给select,会自动找到对应的下拉框中的选项
    巩固:
        1. th:each 修饰的标签会被循环
        2. 对同一个表进行了两次join,其逻辑连接上是不同的
        3. $.each(数组,function(index, object){}) this 等于 object 简单用this,复杂用obj
        4. 选择器.append(html) 追加html 选择器.html(html) 覆盖html
              这里不适合用append,因为连续点击导致数据重复
        5. 如果在jquery中触发事件后的回调函数里面的this表示对应的dom对象
        6. .size() 获取jquery数组长度
        7. ajax请求的参数都在data里面,data可以是一个json对象也可以是一个字符串
            1) data:{} 优势:简单 劣势:只能是普通文本,一个name对应一个value
            2) data:name=value&name=value 优势:一个name对应多个value 劣势:复杂
            3) data:fromData对象 优势:可以是普通文本也可以是文件 劣势:更复杂

apache-poi插件
    HSSFWorkbook------文件  wb = new HSSFWorkbook()创建excel文件对象
    HSSFSheet---------页   sheet = wb.createSheet(name)重载方法可以生成默认名字的页面或者是指定名字的页面
    HSSFRow-----------行   row = sheet.createRow(rowNum)在第rowNum行添加数据,0开始
    HSSFCell----------列   cell = row.creatCell(cellNum)在第cellNum列添加数据,0开始
    HSSFCellStyle-----样式  style = wb.createCellStyle()创建样式对象
                                    row.setCellStyle(style) cell.setCellStyle(style) 使用样式

输出流对应的目录一定要存在,否则报错,文件可以不存在
输出流要关,wb也要关
`文件下载`只能发同步请求,因为如果发异步请求,是ajax发送的请求,ajax处理不了文件,所以只能发同步请求
而且同步请求返回的文件也不会覆盖页
响应信息如果浏览器打不开,就会调用应用程序打开,依旧打不开,就文件下载,可以设置响应头信息直接以附件形式下载
遍历之前查看list集合是否为空且长度大于0,避免空指针异常和提高效率
文件下载的异常捕获也没有用,因为文件下载以附件的形式存在,不会显示returnMsg
注意要flush一下,否在可能会在缓冲区造成数据丢失

wb.write() while((len = is.read(bytes)) != -1) os.write(bytes, 0, len) 效率非常低
因为这两个操作都操作了磁盘,进行了IO操作

文件上传的表单三大条件
1.文件上传对应的组件必须是<input type='file'>
2.必须发post请求
    get:参数通过请求头发给后台,在uri后面拼接,只可以发文本数据,对长度有限制,效率较高(get里面的只是文件名)
    post:参数通过请求体发给后台,即可以发文本数据,也可以发二进制数据,对长度没有限制,效率较低[效率差别很小,忽略不计]
3.表单的编码只能用multipart/form-data[阻止浏览器进行下面的操作]
    根据HTTP协议,表单提交数据,浏览器会对数据进行统一的编码,默认的编码是urlencoded,,该编码修饰的是纯文本数据,如果遇到数值型数据
    会将其转换为纯文本数据,文件上传的是二进制数据,如果转换为纯文本数据会报错

multipartResolver:maxUploadSize最大上传大小,以byte为单位,超过就会抛异常
                  defaultEncoding:默认编码
transferTo(file) 文件可以不存在,目录必须要存在
浏览器解析不了json
new File(路径, 文件名)

一般通过页的下标获取页,页的名称获取可能会因为字符编码的问题获取不到
getLastRowNum()最后一行的下标 getLastCellNum()最后一列的下标+1
request.getParameter和封装的方法类似,不论给什么数据类型,都转换成String返回
在判断的时候,我们可以创建一个枚举类型表示状态
在导入数据的时候,导入列表不需要id,因为用户填写的id可能会重复,也与数据库的其他id不同
              导入列表也不需要所有者,因为如果填写用户名
              1.控制层调用业务层在调用持久化层查询对应的所有者名字,可能出现多个,这种方式不行
              2.如果采取附录的形式,只适合owner少量情况也不适合
              3.只能采取共享用户,所以不需要所有者
              4.谁导入的所有者是谁,也不需要所有者(采取该方式)
              导入列表也不需要创建时间,创建时间就是当前导入的时间,同理创建者就是导入的人
              修改者和修改时间也不需要
              批量保存判断影响记录也没有意义,因为成功了一条也算成功,在前台显示一条即可
              注意文件的后缀名不区分大小写

.val()获取的只是文件名,不可以获取文件内容
subStr(index) index到最后
dom对象有files属性,专门放文件内容,files是一个数组
.size获取文件的大小
mybatis if标签里面的数组也要用array,其他同理list等
mybatis 直接.属性名 不需要get

FormData最大的优势:能提交二进制数据
append(name, value)拼接键值对
join on 本质上也是过滤条件

ajax参数
processData:默认是true,表示将所有的参数自动变为纯文本参数,对于文件来说肯定是不行的,所以改为false
contentType:默认是true,表示将所哟的参数自动编码为urlencoded,所以改为false
新知识:
    byteArrayOutputStream
    thymeleaf自定义属性
        th:attr="data-属性名=XXX, data-属性名=XXX"

鼠标悬停图片上,对应的title属性值会显示
我们可以利用标签中的属性来存储我们所需要的数据
如果是表单组件的时候,优先使用value属性[方便],如果value被占用,则采用自定义属性(可以给标签随意加属性)
如果不是表单组件,不推荐使用value属性[浏览器可能报错],推荐使用自定义属性
自定义属性只可以通过:jquery对象.attr("属性名")获取
一般是一个资源目录一个controller,如果对应的controller太长,可以再弄一个controller,便于维护
当js代码被执行的时候,thymeleaf早就解析好了

选择器.after()  追加html代码到指定标签外部的后面
选择器.append() 追加html代码到指定标签内部的后面
选择器.before() 追加html代码到指定标签外部的前面
选择器.remove() 删除标签

注意添加成功后还需要查一下对应的名字,通过隐藏域或者`重新封装返回的东西`
注意添加事件代码的转换
选择器中回调函数的this表示被选中的东西
自定义属性也可以区分标签,定位标签优先使用id,如果id不方便就采用name,再者在考虑自定义属性
备注列表动态刷新,不查询数据库,避免影响效率
避免id冲突,一般在前面加 标签名_ 例如:div_  主要用于删东西的

------------------

原来怎么写,现在怎么写,避免页面变形


// 优化returnMsg残留的对象

线索
    数据字典类型的表中,code作为主键,code具有业务含义,这样做的好处是可以在程序中直接写死(直接使用)
    直观:唯一性键列和主键列才可以被外键依赖,如果我们想要根据类型查找对应的下拉列表选项,我可以直接传一个外键值作为过滤条件
    而这个外键值必定在类型表中,如果类型表多出一个唯一性键列非常的麻烦,不如直接作为主键列
    因为数据字典的记录比较少,主键重复的几率比较小,所以可以用有业务含义的字段做主键

    @MapKey @Param

    一般不用图片作为图标,因为图片很大,存储在服务器,传输需要耗费资源和时间,导致后台压力大,用户体验差
    .text() 只可以获取初始内容 .val() 可以获取改变后的内容
    List集合返回一个json数组
    注意数据的干掉(效果:选择过的都删掉,其他不改变)

    数据转换:
    1.线索表中个人的信息转换到联系人表 edit× QBC
    2.线索表中公司的信息转换到客户表 edit×  QBC
    3.线索的备注表分别转换到客户和联系人的备注表 edit√ 需要对List加以判断[原来怎么样,现在怎么样]  !QBC
    4.线索和市场活动的多对多关系转换到联系人和市场活动的多对多关系 需要对List加以判断[原来怎么样,现在怎么样]  !_QBC
    5.如果需要创建交易,往交易表加记录,并将备注转换到交易备注表中 !_QBC 需要对List加以判断[原来怎么样,现在怎么样]
    6.删除该线索下的所有备注(外键),再删除与市场活动的关联关系,最后删除该线索 QBC
    7.同一个事务完成[在同一个service方法里面完成]
    8.上述过程其 实是依赖和被依赖关系的体现(一定要找好依赖和被依赖关系,先做被依赖的)

    搜索源还需要clueId,因为我们要找线索参加过的市场活动,自定义属性要考虑name和id
    弹模态窗口原则:想初始化,自己弹,否则用原来的就好
    `如果持久化层和业务层过于复杂的时候,我们可以先将一两个流程写完,将整个层级跑通,再将剩下的东西补全`
    service层最好不要有session等web技术,否则就离不开服务器,无法单独调试

    可能性分析:最重要的是配置文件的约定
    配置文件的区别:
         properties:适合配置简单数据,几乎没有冗余字段,语法简单,解析简单,效率高
         xml(可扩展标记语言):适合配置复杂数据,有冗余字段,语法复杂,解析困难,效率低
         阶段名字作为key,可能性作为value
         properties配置文件最好不要有特殊符号
    .find("选择器")找子标签
任务:分页查询(有时间) 回车添加(更改) [转换(参数:线索id,交易表单的参数,交易状态) 主要搞数据字典 < 跳转交易页面+时序图 跳转创建页面+时序图
    可能性分析+时序图

ps:交易名称是动态的

